<?php
    class Controller_Task3 extends Controller
    {
        // --- Основной метод. Просто рендеринг страницы с формой ввода шифра. ---
        public function action_default()
        {
            $data_for_view['title'] = 'Задача 3';   // Массив для вью, элемент которого - title.

            $this->view->generate('task3_view.php', $this->base_view, $data_for_view);
        }
        // --- Конец  action_default(). ------------------------------------------

        public function action_cipher()
        {
            $data_for_view['title'] = 'Задача 3. Расшифровка.';   // Массив для вью, элемент которого - title.
            // Стандартные сообщениЯ, если не будет поста.
            $cipher = '-';
            $result = '-';
            // -------------------------------------------

            if (isset($_POST))
            {
                mb_internal_encoding("UTF-8");

                $cipher = $_POST['cipher'];   // Получаем строку с шифром.
                $lengthStr=mb_strlen($cipher);// Количество символов в строке с шифром.
                // Формируем массив со специальными обозначениями.
                $arraySpecialDes[] = '->';
                $arraySpecialDes[] = '+';
                $arraySpecialDes[] = '-';
                // -----------------------------------------------

                $result ='';   // Переменная для расшифрованной строки. Будет накапливаться поэлементно.
                // --- Перебираем символы зашифрованной строки. Внутри цикла будет
                //     изменяться индекс на некоторые конкретные значения. ---
                for ($i=0; $i<$lengthStr; $i++)
                {
                    // --- Перебираем массив со спец.обозначениями и если текущий символ строки
                    //     с шифром является спец обозначением, принимается решение по смещению индекса. ---
                    foreach ($arraySpecialDes as $indexSpecialDes => $specialDes)
                    {
                        // --- Определять является ли текущий символ специальным, и в таком случае
                        //     отделять от него аргумент, будем с помощью регулярного выражения. ---
                        $specialDes = '\\'.$specialDes;   // Экранируем очередной спец. символ из массива.
                        $pattern = "/^$specialDes(?<"."argument".">\d+)/u";   // Шаблон поиска. Очередной(текущий) символ зашифрованной строки будет считаться
                                                                              // началом строки поиска, поэтому сначала должен быть спец символ и за ним любое
                                                                              // количество чисел, которые объединяем в группу и называем ее argument, чтобы
                                                                              // потом по этому ключу вытащить из массива matches значение аргумента, которое
                                                                              // нужно для дальнейшего смещения индекса символа строки с шифром.

                        $find = preg_match($pattern, mb_substr($cipher,$i), $matches);   // Ищем совпадение по шаблону в строке с шифром от текущего символа.
                        // --- Конец работы с регуляркой. ------------------------------------------------
                        // --- Если поиск удачен, то принимаем соответствующие решения по смещению. ---
                        if ($find==1)
                        {
                            $countFind = strlen($matches[0]);   // Длина строки со спец.значением и аргументом.

                            switch ($indexSpecialDes)
                            {
                                case 0:   // ->
                                    $i=$matches['argument'] -1;   // ... Учитываем инкрементирование. Так как символ добавится на следующей итерации.

                                    break;
                                case 1:   // +
                                    $i = $i + $countFind + $matches['argument']-1;   // ... Учитываем инкрементирование. Так как символ добавится на следующей итерации.

                                    break;
                                case 2:   // -

                                    $i = $i + $countFind  - $matches['argument'] -2;   // ... Учитываем инкрементирование. Так как символ добавится на следующей итерации.

                                    break;
                            }
                            break;
                        }
                        // ----- Конец смещения индекса. ----------------------------------------------
                        unset($find);
                    }
                    // ------Конец перебора спец обозначений. ----------------------------------------------
                    // --- Если переменной $find не существует, то это означает, что текущий
                    //     символ не является спец обозначением и может быть добавлен к расшифрованной
                    //     строке. Это может быть либо после смещения, либо просто символ обычный. ---
                    if (empty($find))
                    {
                        $result.=mb_substr($cipher, $i,1);   // Добавляем текущий символ.
                    }
                    // -------------------------------------------------------------------------------
                }
                // --- Конец перебора символов по строке с шифром. -----------
            }

            $data_for_view['cipher'] = $cipher;   // Массив для вью, элемент которого - введенный шифр.
            $data_for_view['result'] = $result;   // Массив для вью, элемент которого - расшифрованная строка.

            $this->view->generate('task3_result_view.php', $this->base_view, $data_for_view);
        }
    }
?>